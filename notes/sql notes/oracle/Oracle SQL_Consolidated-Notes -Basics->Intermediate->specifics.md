<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" style="height:64px;margin-right:32px"/>

# Oracle SQL: Consolidated Notes (Basics → Intermediate → Specifics)

Important rules honored:

- No repetition: If syntax/behavior is the same as in other DBs, it’s not repeated here.
- If concept is same but Oracle query differs, only the Oracle query is shown.
- If both concept and query differ, both are provided.

These notes are derived from the attached materials and reframed for Oracle only, minimizing redundancy. Citations refer to the provided attachments.

## 1) Core SQL Building Blocks

### 1.1 DDL Essentials (CREATE, ALTER, DROP, RENAME, TRUNCATE)

- CREATE database-level objects differ in Oracle:
    - No CREATE DATABASE in a session like MySQL; databases are created at instance level by DBAs.
- CREATE TABLE (Oracle syntax differences):
    - Identity columns use GENERATED AS IDENTITY instead of AUTO_INCREMENT/IDENTITY.

Oracle examples:

```sql
-- Create table with identity
CREATE TABLE employees (
  emp_id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  name   VARCHAR2(100) NOT NULL,
  salary NUMBER(10,2),
  hire_date DATE
);

-- Add column
ALTER TABLE employees ADD department VARCHAR2(50);

-- Modify column type
ALTER TABLE employees MODIFY hire_date TIMESTAMP;

-- Rename table
RENAME employees TO staff;

-- Drop table
DROP TABLE staff;

-- Truncate
TRUNCATE TABLE some_large_table;
```

Notes:

- VARCHAR2 is Oracle’s standard variable-length string.
- NUMBER(p,s) is Oracle’s general numeric type (no separate DECIMAL/NUMERIC types as distinct implementations).
- DATE stores date and time to seconds in Oracle; TIMESTAMP adds fractional seconds and optional time zone.

Reference mapping from attached MySQL/MSSQL examples adjusted to Oracle types and identity behavior.[^1][^2]

### 1.2 DML Essentials (INSERT, SELECT, UPDATE, DELETE)

Oracle examples:

```sql
-- Insert
INSERT INTO employees (name, salary, hire_date) 
VALUES ('Alice', 72000.00, DATE '2025-08-10');

-- Select
SELECT name, salary FROM employees WHERE salary >= 60000 ORDER BY salary DESC;

-- Update
UPDATE employees SET salary = salary * 1.05 WHERE name = 'Alice';

-- Delete
DELETE FROM employees WHERE emp_id = 10;
```

Transaction control (Oracle is transactional by default):

```sql
COMMIT;
ROLLBACK;
```


### 1.3 Indexes and Views

Oracle examples:

```sql
-- Index
CREATE INDEX idx_emp_name ON employees(name);

-- Composite index
CREATE INDEX idx_emp_dept_salary ON employees(department, salary);

-- View
CREATE OR REPLACE VIEW active_employees AS
SELECT emp_id, name, salary FROM employees WHERE salary > 0;

-- Drop view
DROP VIEW active_employees;
```

The behavior aligns with the intent from other engines; Oracle syntax uses the same statements for these basics.[^3][^2]

## 2) Data Types and Date/Time in Oracle

Conceptual differences from other DBs (both concept and types differ):

- Oracle DATE includes time to seconds (unlike SQL Server DATE which is date-only, or MySQL DATE which is date-only). For fractions/time zones, use TIMESTAMP flavors.[^1]
- TIMESTAMP(p), TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH LOCAL TIME ZONE are Oracle-native; choose based on precision and need to preserve zone/normalize on storage.[^1]

Oracle types quick map:

```text
- Character: CHAR(n), VARCHAR2(n), CLOB
- Numeric: NUMBER(p,s), INTEGER (subtype of NUMBER)
- Date/Time: DATE, TIMESTAMP(p), TIMESTAMP(p) WITH TIME ZONE, TIMESTAMP(p) WITH LOCAL TIME ZONE, INTERVAL YEAR TO MONTH, INTERVAL DAY TO SECOND
- Binary: BLOB, RAW(n)
```

Examples:

```sql
CREATE TABLE time_demo (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  only_date           DATE,                         -- date + time to seconds
  precise_ts          TIMESTAMP(7),                 -- fractional seconds
  with_tz             TIMESTAMP(7) WITH TIME ZONE,  -- preserves offset/region
  with_local_tz       TIMESTAMP(7) WITH LOCAL TIME ZONE, -- normalized to DB TZ
  ym_interval         INTERVAL YEAR TO MONTH,
  ds_interval         INTERVAL DAY TO SECOND
);

INSERT INTO time_demo (only_date, precise_ts, with_tz, with_local_tz, ym_interval, ds_interval)
VALUES (
  DATE '2025-08-10',
  TO_TIMESTAMP('2025-08-10 23:59:59.1234567', 'YYYY-MM-DD HH24:MI:SS.FF7'),
  TO_TIMESTAMP_TZ('2025-08-10 23:59:59.1234567 +05:30', 'YYYY-MM-DD HH24:MI:SS.FF7 TZH:TZM'),
  TO_TIMESTAMP_TZ('2025-08-10 23:59:59.1234567 +00:00', 'YYYY-MM-DD HH24:MI:SS.FF7 TZH:TZM'),
  INTERVAL '3' YEAR,
  INTERVAL '2 12:30:45.123' DAY TO SECOND(3)
);
```

This section adapts cross-engine datetime insights from the attachments to Oracle’s types and functions.[^1]

Essential date/time functions in Oracle (Oracle equivalents where syntax differs):

- Current timestamp: SYSTIMESTAMP; current date/time to seconds: SYSDATE.
- Arithmetic: ADD_MONTHS, MONTHS_BETWEEN, NUMTODSINTERVAL, NUMTOYMINTERVAL.
- Extract: EXTRACT(YEAR FROM ts), TRUNC(date,'unit').
- Formatting: TO_CHAR(ts,'YYYY-MM-DD HH24:MI:SS.FF3 TZH:TZM'); parsing with TO_DATE/TO_TIMESTAMP/TO_TIMESTAMP_TZ.

Examples:

```sql
SELECT SYSDATE AS now_secs, SYSTIMESTAMP AS now_precise FROM dual;

SELECT 
  ADD_MONTHS(DATE '2025-01-31', 1) AS plus_1_month,
  MONTHS_BETWEEN(DATE '2025-08-10', DATE '2025-01-01') AS months_diff
FROM dual;

SELECT 
  EXTRACT(YEAR FROM SYSTIMESTAMP) AS yr, 
  EXTRACT(MONTH FROM SYSTIMESTAMP) AS mon
FROM dual;

SELECT 
  TO_CHAR(SYSTIMESTAMP, 'YYYY-MM-DD"T"HH24:MI:SS.FF3 TZH:TZM') AS iso_ts
FROM dual;
```

Mapped from SQL Server/MySQL examples to Oracle equivalents.[^1]

## 3) Constraints and Keys

Same concepts; Oracle syntax differs (only queries shown):

Primary key, unique, check:

```sql
CREATE TABLE departments (
  dept_id   NUMBER PRIMARY KEY,
  dept_name VARCHAR2(50) UNIQUE,
  status    VARCHAR2(20),
  CONSTRAINT chk_status CHECK (status IN ('active','inactive'))
);

-- Named constraints
CREATE TABLE products (
  product_id NUMBER,
  sku        VARCHAR2(50),
  CONSTRAINT pk_products PRIMARY KEY (product_id),
  CONSTRAINT uk_products_sku UNIQUE (sku)
);

-- Add/drop constraints
ALTER TABLE departments ADD CONSTRAINT uk_dept_name UNIQUE (dept_name);
ALTER TABLE departments DROP CONSTRAINT uk_dept_name;
```

Foreign keys and actions:

- Oracle supports ON DELETE CASCADE/SET NULL; ON UPDATE CASCADE is not supported (must handle updates via triggers/application). This is a conceptual difference versus other engines that support ON UPDATE CASCADE.[^4]

```sql
CREATE TABLE employees (
  emp_id    NUMBER PRIMARY KEY,
  name      VARCHAR2(100),
  dept_id   NUMBER,
  manager_id NUMBER,
  CONSTRAINT fk_emp_dept 
    FOREIGN KEY (dept_id) REFERENCES departments(dept_id) ON DELETE SET NULL,
  CONSTRAINT fk_emp_manager 
    FOREIGN KEY (manager_id) REFERENCES employees(emp_id) ON DELETE SET NULL
);
```

- DEFERRABLE constraints are supported in Oracle (similar to PostgreSQL capability):

```sql
CREATE TABLE parent_child (
  parent_id NUMBER PRIMARY KEY,
  child_id  NUMBER,
  CONSTRAINT fk_parent_child 
    FOREIGN KEY (child_id) REFERENCES parent_child(parent_id)
    DEFERRABLE INITIALLY DEFERRED
);
```

Behavior notes adapted from the FK section; Oracle doesn’t implement ON UPDATE actions like some engines.[^4]

Querying metadata (Oracle views) where attachment used INFORMATION_SCHEMA in MySQL:

```sql
-- Constraints overview
SELECT owner, table_name, constraint_name, constraint_type, status, deferrable, deferred
FROM all_constraints
WHERE owner = USER;

-- Columns in constraints
SELECT owner, table_name, constraint_name, column_name, position
FROM all_cons_columns
WHERE owner = USER;

-- Referential constraints rules (delete rule)
SELECT constraint_name, delete_rule
FROM user_constraints
WHERE constraint_type = 'R';
```

Adjusted from MySQL’s INFORMATION_SCHEMA to Oracle’s data dictionary views.[^4]

## 4) Joins, EXISTS/NOT EXISTS, Correlation

Concepts are the same; Oracle uses identical SQL for core joins and EXISTS/NOT EXISTS shown in the attachments, so not repeated here. Only Oracle nuances where queries differ are added:[^5][^6]

- Oracle prefers ANSI JOIN (same as examples).
- EXISTS/NOT EXISTS identical; scalar SELECT 1 is fine.

Example (unchanged semantics):

```sql
-- EXISTS
SELECT emp_id, name, department_id
FROM employees e
WHERE EXISTS (
  SELECT 1 FROM departments d WHERE d.dept_id = e.department_id
);

-- NOT EXISTS
SELECT dept_id, dept_name
FROM departments d
WHERE NOT EXISTS (
  SELECT 1 FROM employees e WHERE e.department_id = d.dept_id
);
```

No change needed from attached examples for Oracle.[^6][^5]

## 5) GROUP BY, HAVING, ROLLUP/CUBE, GROUPING SETS

Concepts are the same; Oracle supports ROLLUP, CUBE, GROUPING SETS closely aligned with the attachments, so just Oracle examples:

```sql
-- Basic GROUP BY with HAVING
SELECT department, COUNT(*) AS total_employees
FROM employees
GROUP BY department
HAVING COUNT(*) >= 5
ORDER BY total_employees DESC;

-- ROLLUP
SELECT department, role, SUM(salary) AS total_salary
FROM employees
GROUP BY ROLLUP (department, role);

-- CUBE
SELECT department, role, SUM(salary) AS total_salary
FROM employees
GROUP BY CUBE (department, role);

-- GROUPING SETS
SELECT department, role, SUM(salary) AS total_salary
FROM employees
GROUP BY GROUPING SETS (
  (department, role),
  (department),
  ()
);
```

Behavior mirrors the guidance in the attachment; only Oracle queries shown.[^7]

## 6) ORDER BY specifics

Concepts same; Oracle handles NULLS FIRST/NULLS LAST explicitly like PostgreSQL:

```sql
SELECT name, score
FROM players
ORDER BY score DESC NULLS LAST;
```

Custom sort with CASE works the same:

```sql
SELECT name, status
FROM orders
ORDER BY CASE status
  WHEN 'urgent' THEN 1
  WHEN 'high'   THEN 2
  WHEN 'normal' THEN 3
  ELSE 4
END;
```

Collation specifics differ per DB; Oracle generally relies on NLS settings; explicit COLLATE is not commonly used like MySQL/SQL Server examples; omitting repetition from attachments where not applicable.[^8]

Pagination:

- Oracle 12c+ supports OFFSET/FETCH:

```sql
SELECT *
FROM orders
ORDER BY order_date DESC, order_id DESC
OFFSET 10 ROWS FETCH NEXT 10 ROWS ONLY;
```

- Keyset pagination pattern is the same conceptually; use WHERE on last seen keys.

Tie-breakers same recommendation as attachments.[^8]

## 7) Window Functions: PARTITION BY, Ranking, LAG/LEAD

Concepts same and fully supported in Oracle; only Oracle examples:

Per-group ranks and running totals:

```sql
-- RANK vs DENSE_RANK per department
SELECT
  e.department_id,
  e.employee_name,
  e.salary,
  RANK()       OVER (PARTITION BY e.department_id ORDER BY e.salary DESC)       AS rnk,
  DENSE_RANK() OVER (PARTITION BY e.department_id ORDER BY e.salary DESC)       AS dense_rnk
FROM employees e
ORDER BY department_id, salary DESC;

-- Running total per customer
SELECT
  o.customer_id,
  o.order_id,
  o.order_date,
  o.total_amount,
  SUM(o.total_amount) OVER (
    PARTITION BY o.customer_id
    ORDER BY o.order_date, o.order_id
    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
  ) AS running_total
FROM orders o;
```

Top-N per group with ROW_NUMBER and outer filter:

```sql
SELECT *
FROM (
  SELECT
    o.*,
    ROW_NUMBER() OVER (
      PARTITION BY o.customer_id
      ORDER BY o.order_date DESC, o.order_id DESC
    ) AS rn
  FROM orders o
)
WHERE rn = 1;
```

Percentile-like distributions and NTILE:

```sql
SELECT
  e.department_id,
  e.employee_name,
  e.salary,
  PERCENT_RANK() OVER (PARTITION BY e.department_id ORDER BY e.salary) AS pct_rank,
  CUME_DIST()   OVER (PARTITION BY e.department_id ORDER BY e.salary) AS cume_dist,
  NTILE(10)     OVER (ORDER BY e.salary DESC) AS decile
FROM employees e;
```

Matches attachment concepts; Oracle supports full window functionality.[^9][^10]

## 8) Self-Join and Hierarchies

Self-join is identical conceptually; Oracle also provides CONNECT BY/START WITH for hierarchical queries.

Only Oracle additions (feature difference: hierarchical query syntax):

```sql
-- Self-join to get manager
SELECT e.employee_name AS employee, m.employee_name AS manager
FROM employees e
LEFT JOIN employees m ON e.manager_id = m.employee_id;

-- Hierarchical query (Oracle-specific)
SELECT 
  LPAD(' ', 2*(LEVEL-1)) || employee_name AS employee_tree,
  employee_id, manager_id, LEVEL
FROM employees
START WITH manager_id IS NULL
CONNECT BY PRIOR employee_id = manager_id
ORDER BY LEVEL, employee_name;
```

This extends beyond the attachments with Oracle’s native hierarchy support; included because both concept and query differ for hierarchical traversal compared to other engines.[^6]

## 9) Text, Quoting, and Smart Quotes

Concept is the same; Oracle string literal escaping:

- Single quote escape by doubling:

```sql
SELECT 'O''Reilly' AS val FROM dual;
```

- Double quotes are for identifiers, not string literals.
- To handle smart quotes like U+2019, normalize via REPLACE or during ETL (parallel advice to attachments):

```sql
SELECT REPLACE(desp, UNISTR('\2019'), '''') AS normalized
FROM ai_models;

-- Update to normalize
UPDATE ai_models
SET desp = REPLACE(desp, UNISTR('\2019'), '''')
WHERE instr(desp, UNISTR('\2019')) > 0;
```

This mirrors the anti-“smart quotes” guidance from the attachments in Oracle form.[^11]

## 10) Constraints: Performance and Validation

Oracle parallels best practices:

- Create indexes supporting FK lookups manually (Oracle does not auto-index FK columns).
- Use DEFERRABLE when needed for bulk loads; validate after load:

```sql
ALTER TABLE big_table DISABLE CONSTRAINT fk_big_parent;
-- bulk load
ALTER TABLE big_table ENABLE NOVALIDATE CONSTRAINT fk_big_parent;
ALTER TABLE big_table ENABLE VALIDATE CONSTRAINT fk_big_parent; -- full validation
```

Adapted from check/validate patterns in other engines with Oracle enable/validate controls.[^4]

## 11) Default Values and Generated Columns

Oracle differences:

- Default values and generated columns exist with Oracle syntax.

Examples:

```sql
CREATE TABLE audit_log (
  log_id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  log_message CLOB,
  log_timestamp TIMESTAMP DEFAULT SYSTIMESTAMP,
  log_user VARCHAR2(100) DEFAULT USER,
  session_id NUMBER DEFAULT SYS_CONTEXT('USERENV','SESSIONID')
);

-- Virtual and stored generated columns
CREATE TABLE products (
  product_id NUMBER PRIMARY KEY,
  base_price NUMBER(10,2),
  tax_rate   NUMBER(5,4) DEFAULT 0.08,
  final_price GENERATED ALWAYS AS (base_price * (1 + tax_rate)) VIRTUAL,
  CONSTRAINT chk_positive_price CHECK (base_price > 0),
  CONSTRAINT chk_valid_tax_rate CHECK (tax_rate >= 0 AND tax_rate <= 1)
);
```

Adjusted from PostgreSQL/MySQL generated columns notes to Oracle’s VIRTUAL/STORED options (Oracle supports VIRTUAL; STORED depends on version).[^4][^1]

## 12) Advanced: Temporal and Graph-like features

Attachments discussed SQL Server temporal tables and graph features; Oracle equivalents are different:

- Oracle has Flashback Data Archive (Total Recall) for temporal history and Flashback Query for point-in-time queries; setup and usage differ (concept differs and queries differ).
- Oracle Spatial/Graph exists but with different DDL than SQL Server graph nodes/edges.

Brief Oracle-only pointers:

```sql
-- Flashback Query (point-in-time)
SELECT * FROM employees AS OF TIMESTAMP SYSTIMESTAMP - INTERVAL '1' HOUR;

-- Flashback Data Archive requires setup (DBA); once enabled, historical queries use VERSIONS BETWEEN:
SELECT emp_id, name, versions_starttime, versions_endtime
FROM employees VERSIONS BETWEEN TIMESTAMP
  SYSTIMESTAMP - INTERVAL '1' DAY AND SYSTIMESTAMP
WHERE emp_id = 100;
```

Included because concept and implementation differ from SQL Server’s temporal tables in the attachments.

## 13) Error Handling Patterns

Constraint violations in Oracle:

- ORA-02290: check constraint violated.
- ORA-02291/02292: integrity constraint violated – parent key not found / child record found.
Same logic as attachments; error codes differ, so not repeating messages.


## 14) Performance Guidance (Oracle-focused)

- Index join keys and partitioning keys when partitioning is used.
- Use EXPLAIN PLAN FOR and SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY) to inspect plans.
- For heavy ORDER BY/LARGE sorts, ensure PGA/Temp is provisioned; avoid unnecessary sorts via matching indexes.
- Use parallel query judiciously: SELECT /*+ PARALLEL(t,4) */ ... FROM big_table t.


## 15) Cheatsheet: Oracle-only versions of common cross-DB snippets

- Inline FK definition (supported; ON UPDATE not supported):

```sql
CREATE TABLE orders (
  order_id   NUMBER PRIMARY KEY,
  customer_id NUMBER REFERENCES customers(customer_id),
  order_date DATE DEFAULT SYSDATE
);
```

- Email/phone format checks with REGEXP_LIKE:

```sql
ALTER TABLE users ADD CONSTRAINT chk_email
  CHECK (REGEXP_LIKE(email, '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'));

ALTER TABLE users ADD CONSTRAINT chk_phone
  CHECK (REGEXP_LIKE(phone, '^\+?[1-9]\d{1,14}$'));
```

Adjusted from MySQL/PostgreSQL regex examples to Oracle’s REGEXP_LIKE.[^4]

- Hour bucketing:

```sql
SELECT
  CAST(TRUNC(created_at, 'HH24') AS TIMESTAMP) AS hour_bucket,
  COUNT(*) AS rows_per_hour
FROM events
GROUP BY TRUNC(created_at, 'HH24')
ORDER BY hour_bucket;
```

Adapted from date_trunc/EOMONTH patterns to Oracle TRUNC(date,'unit').[^1]

- Pagination (OFFSET/FETCH):

```sql
SELECT *
FROM products
ORDER BY product_name, product_id
OFFSET 50 ROWS FETCH NEXT 25 ROWS ONLY;
```

Tie-breaker included in ORDER BY to stabilize pages as advised in the attachments.[^8]

- Top-N per group with outer filter (QUALIFY alternative):

```sql
SELECT *
FROM (
  SELECT
    p.category,
    p.product_name,
    SUM(o.quantity) AS qty,
    RANK() OVER (PARTITION BY p.category ORDER BY SUM(o.quantity) DESC) AS rnk
  FROM products p
  JOIN orders o ON o.product_id = p.product_id
  GROUP BY p.category, p.product_name
)
WHERE rnk <= 3
ORDER BY category, rnk, qty DESC, product_name;
```

Same pattern as attachments; Oracle does not have QUALIFY, so subquery filter is used.[^10][^9]

***

Notes source attribution:

- Constraint types, FK actions, and performance best practices adapted and aligned to Oracle syntax from the constraints guide.[^4]
- EXISTS/NOT EXISTS, correlation, optimization principles reused where identical semantics apply.[^5]
- Date/time behaviors mapped to Oracle’s DATE/TIMESTAMP types and functions.[^1]
- GROUP BY, ORDER BY, window functions adapted to Oracle with Oracle-native syntax while preserving attached guidance.[^7][^9][^10][^8]
- Joins/self-joins retained as-is; Oracle hierarchy extensions added.[^6]
- Text/escaping guidance adapted to Oracle (UNISTR for smart quotes normalization).[^11]
- DDL/DML/index/view patterns transformed from MySQL/SQL Server examples to Oracle equivalents.[^2][^3]

[^9][^10][^3][^2][^5][^7][^11][^6][^8][^4][^1]

<div style="text-align: center">⁂</div>

[^1]: sql_datetime.md

[^2]: sql-basics.md

[^3]: sql_serverfunc.md

[^4]: sql_constraints.md

[^5]: sql_correlation_exists_not.md

[^6]: sql_joins.md

[^7]: sql_groupby.md

[^8]: sql_orderby.md

[^9]: sql_partitionby.md

[^10]: sql_rank.md

[^11]: sql_inter.md

[^12]: sources_sql.md

